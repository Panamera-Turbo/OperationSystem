```c
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<fcntl.h>
#include<dirent.h>
#include<sys/types.h>
#include<sys/stat.h>
#include<string.h>

#define FILE_MODE 0777

void file_copy(const char *pathsrc, const char *pathdes)
{
    int fidsrc = open(pathsrc, O_RDONLY), fiddes = open(pathdes, O_CREAT | O_TRUNC | O_RDWR, FILE_MODE);
    if(fidsrc == -1 || fiddes == -1){
        printf("文件打开失败\n");
        return;
    }
    char buf[512];
    while(read(fidsrc, buf, 512) > 0){
        write(fiddes, buf, strlen(buf));
    }
    close(fidsrc);
    close(fiddes);
}

void dir_copy(const char* old_path, const char* new_path)
{
    DIR * opdir = opendir(old_path);
	if(opdir == NULL){
        printf("打开源目录失败\n");
        return;
    }

    DIR * newdir = opendir(new_path);
    if(newdir == NULL){
        int res = mkdir(new_path, 0777);
        if(res == -1){
            printf("创建新目录失败\n");
            return;
        }
    }
    struct dirent * redir;
    while(redir = readdir(opdir)){
        if(strcmp(redir->d_name, ".") == 0 || strcmp(redir->d_name, "..") == 0){
            continue; //跳过两个隐藏文件
        }
        char next_old[512], next_new[512];
        strcpy(next_old, old_path);
        strcpy(next_new, new_path);
        strcat(next_old, "/"); strcat(next_old, redir->d_name);
        strcat(next_new, "/"); strcat(next_new, redir->d_name);
        if((redir->d_type & DT_REG) == DT_REG)//如果读到的文件是普通文件则复制
			file_copy(next_old, next_new);    
		else if((redir->d_type & DT_DIR) == DT_DIR)//如果读到的是目录则递归处理目录
			dir_copy(next_old, next_new);
    }
}

int main(int argc, char* argv[])
{
    if(argc != 3){
        printf("参数异常\n");
    }

    struct stat msg;
    stat(argv[1], &msg);
    if(S_ISDIR(msg.st_mode))
		dir_copy(argv[1],argv[2]);
	else{//否则按照文件直接复制
		file_copy(argv[1],argv[2]);
    }
    
    

    // char buf[512];
    // getcwd(buf, 512);
    // puts(buf);
}
```
